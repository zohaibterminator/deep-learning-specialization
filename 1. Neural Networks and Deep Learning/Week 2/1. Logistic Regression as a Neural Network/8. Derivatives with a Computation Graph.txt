Lets take a look back at the computation graph we constructed. What if we had to calculate the dJ/dv? (if the value of v changed a bit, how would the value of J change). Well, J is defined as 3*v, and right now v, is 11, so J is 33. Let's say that we change the value by 0.001 and make it 11.001, the value of J will become 33.003, meaning the value of J increased by 3 times when the value of v was changed by 0.001, whic then mean dJ/dv is 3. So, in the termninolgy of bacpropagation, we need to take one step backwards to calculate the value of derivative of J with respect to v.

What if we want to calculate dJ/da? In other words, if we bump up the value of a, how is the value of J affected? In the example, a=5. Lets say we bump up the value of a by 0.001, which will mean that v will become 11.001, and if v is increased by 0.001, we have seen that then J is increased by 3 times, to 33.003. So, if yo change a, that will change v, which will then change J. So, dJ/da becomes dJ/dv*dv/da. This is actually called chain rule in calculas, is that if v changes when you change a, and J changes when you change v, then the rate at which J changes w.r.t is the product of dJ/dv and dv/da. We calculated dJ/dv and dv/da to be calculated as 3 and 1 respectively, so the product of both will be 3, which means dJ/da is 3 as well. Which shows, how calculating the dJ/dv helped you calculated dJ/da. Similarly, for dJ/du, the derivative will be the same, i.e. 3. When calculating dJ/db, we will again use the chain rule, and calculate dJ/du and du/db. dJ/du, as we have calcuated, is 3, but when we calculate du/db for b=3.001, u turns out to be 6.002, because c=2, and u is the product of b and c, which results in 6.002. This means that dv/db is 2. So, through chain rule, we can calculate dJ/db to be 6. If you calculate dJ/dc, it turns out to be 9.

We will just want to introduce one more new notational convention, which is that when you're witting codes to implement backpropagation, there will usually be some final output variable that you really care about and want to optimize. And in this case, this final output variable is J. So, a lot of computations will be trying to compute the derivative of that final output variable. So d of this final output variable with respect to some other variable. Then we just call that dvar. So a lot of the computations you have will be to compute the derivative of the final output variable, J in this case, with various intermediate variables, such as a, b, c, u or v. And when you implement this in software, what do you call this variable name? One thing you could do is in Python, you could give us a very long variable name like dFinalOurputVar/dvar. But that's a very long variable name. You could call this, I guess, dJdvar. But because you're always taking derivatives with respect to dJ, with respect to this final output variable, we will be going to introduce a new notation. Where, in code, when you're computing this thing in the code you write, we're just going to use the variable name dvar in order to represent that quantity. So dvar in a code you write will represent the derivative of the final output variable you care about such as J. 